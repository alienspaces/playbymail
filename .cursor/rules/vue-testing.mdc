
# Vue.js Testing Patterns - What We Actually Do

This rule documents the actual testing patterns we use in this project. No bullshit, no idealized patterns - just what works for us.

## Test File Structure

### Component Tests
For reusable components (`.vue` files in `src/components/`):

```javascript
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import ComponentName from './ComponentName.vue'

describe('ComponentName', () => {
  // Mock data at the top
  const mockProps = {
    // Define mock props
  }

  it('renders correctly with default props', () => {
    const wrapper = mount(ComponentName, {
      props: mockProps
    })
    
    expect(wrapper.find('.expected-class').exists()).toBe(true)
    expect(wrapper.text()).toContain('Expected text')
  })

  it('handles prop changes', async () => {
    const wrapper = mount(ComponentName, {
      props: mockProps
    })
    
    await wrapper.setProps({ newProp: 'new value' })
    expect(wrapper.vm.someComputed).toBe('expected result')
  })

  it('emits events correctly', async () => {
    const wrapper = mount(ComponentName, {
      props: mockProps
    })
    
    await wrapper.find('button').trigger('click')
    expect(wrapper.emitted('eventName')).toBeTruthy()
  })

  it('renders loading state', () => {
    const wrapper = mount(ComponentName, {
      props: { ...mockProps, loading: true }
    })
    
    expect(wrapper.text()).toContain('Loading...')
  })

  it('renders error state', () => {
    const wrapper = mount(ComponentName, {
      props: { ...mockProps, error: 'Error message' }
    })
    
    expect(wrapper.find('.error').text()).toBe('Error message')
  })
})
```

### View Tests
For page-level views (`.vue` files in `src/views/`):

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import ViewName from './ViewName.vue'

// Mock APIs
vi.mock('../api/someApi', () => ({
  someApiCall: vi.fn()
}))

describe('ViewName', () => {
  // Simple mounting helper
  const mountWithMocks = (routeQuery = {}) => mount(ViewName, {
    global: {
      mocks: {
        $route: { query: routeQuery },
        $router: { push: vi.fn() }
      }
    }
  })

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders initial state correctly', () => {
    const wrapper = mountWithMocks()
    expect(wrapper.find('.main-content').exists()).toBe(true)
  })

  it('handles form submissions', async () => {
    const { someApiCall } = await import('../api/someApi')
    someApiCall.mockResolvedValue({ success: true })
    
    const wrapper = mountWithMocks()
    
    await wrapper.find('input').setValue('test value')
    await wrapper.find('form').trigger('submit')
    
    expect(someApiCall).toHaveBeenCalledWith('test value')
  })

  it('shows loading state', async () => {
    const wrapper = mountWithMocks()
    wrapper.vm.loading = true
    await wrapper.vm.$nextTick()
    
    expect(wrapper.find('button').attributes('disabled')).toBeDefined()
  })

  it('shows error message', async () => {
    const wrapper = mountWithMocks()
    wrapper.vm.error = 'Error message'
    await wrapper.vm.$nextTick()
    
    expect(wrapper.find('.error').text()).toBe('Error message')
  })
})
```

### Store Integration Tests
For views that use Pinia stores:

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import { ref } from 'vue'
import ViewName from './ViewName.vue'

// Mock stores
vi.mock('../../stores/someStore', () => ({
  useSomeStore: vi.fn(() => ({
    data: [],
    loading: false,
    error: null,
    fetchData: vi.fn()
  }))
}))

describe('ViewName', () => {
  let pinia

  // Helper for store mocking
  const setupStoreMocks = async (customData = {}) => {
    const { useSomeStore } = await import('../../stores/someStore')
    useSomeStore.mockReturnValue({
      data: customData.data || [],
      loading: customData.loading || false,
      error: customData.error || null,
      fetchData: vi.fn()
    })
  }

  beforeEach(() => {
    pinia = createPinia()
    setActivePinia(pinia)
    vi.clearAllMocks()
  })

  it('renders when data is loaded', async () => {
    await setupStoreMocks({ data: [{ id: 1, name: 'Test' }] })
    const wrapper = mount(ViewName)
    
    expect(wrapper.find('.data-item').text()).toBe('Test')
  })

  it('shows loading state', async () => {
    await setupStoreMocks({ loading: true })
    const wrapper = mount(ViewName)
    
    expect(wrapper.text()).toContain('Loading...')
  })

  it('shows error state', async () => {
    await setupStoreMocks({ error: 'Error message' })
    const wrapper = mount(ViewName)
    
    expect(wrapper.find('.error').text()).toBe('Error message')
  })
})
```

## What We Actually Test

### 1. Component Testing
- **Props**: Does it render with different prop values?
- **Events**: Does it emit events when user interacts?
- **States**: Loading, error, empty states
- **Rendering**: Does it show the right content?

### 2. View Testing
- **Form submissions**: Do forms call APIs correctly?
- **User interactions**: Do buttons/links work?
- **Loading states**: Does UI show loading indicators?
- **Error handling**: Do errors display properly?
- **Navigation**: Do router calls work?

### 3. Store Testing
- **Data rendering**: Does store data show in UI?
- **State changes**: Do loading/error states work?
- **Store methods**: Are store methods called correctly?

## Mocking Patterns We Actually Use

### API Mocking
```javascript
vi.mock('../api/apiName', () => ({
  apiCall: vi.fn()
}))

// In tests
const { apiCall } = await import('../api/apiName')
apiCall.mockResolvedValue(expectedResponse)
```

### Router Mocking
```javascript
const mountWithMocks = () => mount(Component, {
  global: {
    mocks: {
      $route: { query: {} },
      $router: { push: vi.fn() }
    }
  }
})
```

### Store Mocking
```javascript
vi.mock('../../stores/storeName', () => ({
  useStoreName: vi.fn(() => ({
    data: [],
    loading: false,
    error: null,
    fetchData: vi.fn()
  }))
}))
```

## Test Organization

### Structure
1. **Imports and mocks** at the top
2. **Helper functions** for mounting/mocking
3. **Basic rendering tests**
4. **User interaction tests**
5. **State tests** (loading, error, success)
6. **Edge cases**

### Naming
- `it('renders correctly')`
- `it('shows loading state')`
- `it('handles form submission')`
- `it('displays error message')`

### Assertions
- Use `.toBe()`, `.toContain()`, `.toHaveLength()`
- Test one thing per test
- Focus on user-facing behavior

## Best Practices We Follow

1. **Keep it simple**: Don't over-engineer tests
2. **Test behavior, not implementation**: Focus on what users see
3. **Mock external dependencies**: APIs, router, stores
4. **Clear test names**: Describe what the test does
5. **Use async/await**: For form submissions and state changes

## What We Don't Do

- Complex accessibility testing
- Overly sophisticated mocking patterns
- Testing implementation details
- Complex test utilities
- Testing every possible edge case

This is what we actually do. Keep it simple, test the important stuff, and focus on user behavior.

})
```

This testing pattern ensures consistent, maintainable, and comprehensive test coverage across all Vue.js components and views.
